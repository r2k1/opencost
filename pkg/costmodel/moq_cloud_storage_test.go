// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package costmodel

import (
	"sync"
)

// Ensure, that CloudStorageMock does implement CloudStorage.
// If this is not the case, regenerate this file with moq.
var _ CloudStorage = &CloudStorageMock{}

// CloudStorageMock is a mock implementation of CloudStorage.
//
//	func TestSomethingThatUsesCloudStorage(t *testing.T) {
//
//		// make and configure a mocked CloudStorage
//		mockedCloudStorage := &CloudStorageMock{
//			ExistsFunc: func(name string) (bool, error) {
//				panic("mock out the Exists method")
//			},
//			ReadFunc: func(name string) ([]byte, error) {
//				panic("mock out the Read method")
//			},
//			WriteFunc: func(name string, data []byte) error {
//				panic("mock out the Write method")
//			},
//		}
//
//		// use mockedCloudStorage in code that requires CloudStorage
//		// and then make assertions.
//
//	}
type CloudStorageMock struct {
	// ExistsFunc mocks the Exists method.
	ExistsFunc func(name string) (bool, error)

	// ReadFunc mocks the Read method.
	ReadFunc func(name string) ([]byte, error)

	// WriteFunc mocks the Write method.
	WriteFunc func(name string, data []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Name is the name argument value.
			Name string
		}
		// Read holds details about calls to the Read method.
		Read []struct {
			// Name is the name argument value.
			Name string
		}
		// Write holds details about calls to the Write method.
		Write []struct {
			// Name is the name argument value.
			Name string
			// Data is the data argument value.
			Data []byte
		}
	}
	lockExists sync.RWMutex
	lockRead   sync.RWMutex
	lockWrite  sync.RWMutex
}

// Exists calls ExistsFunc.
func (mock *CloudStorageMock) Exists(name string) (bool, error) {
	if mock.ExistsFunc == nil {
		panic("CloudStorageMock.ExistsFunc: method is nil but CloudStorage.Exists was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(name)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedCloudStorage.ExistsCalls())
func (mock *CloudStorageMock) ExistsCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// Read calls ReadFunc.
func (mock *CloudStorageMock) Read(name string) ([]byte, error) {
	if mock.ReadFunc == nil {
		panic("CloudStorageMock.ReadFunc: method is nil but CloudStorage.Read was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	mock.lockRead.Unlock()
	return mock.ReadFunc(name)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//	len(mockedCloudStorage.ReadCalls())
func (mock *CloudStorageMock) ReadCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockRead.RLock()
	calls = mock.calls.Read
	mock.lockRead.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *CloudStorageMock) Write(name string, data []byte) error {
	if mock.WriteFunc == nil {
		panic("CloudStorageMock.WriteFunc: method is nil but CloudStorage.Write was just called")
	}
	callInfo := struct {
		Name string
		Data []byte
	}{
		Name: name,
		Data: data,
	}
	mock.lockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	mock.lockWrite.Unlock()
	return mock.WriteFunc(name, data)
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//
//	len(mockedCloudStorage.WriteCalls())
func (mock *CloudStorageMock) WriteCalls() []struct {
	Name string
	Data []byte
} {
	var calls []struct {
		Name string
		Data []byte
	}
	mock.lockWrite.RLock()
	calls = mock.calls.Write
	mock.lockWrite.RUnlock()
	return calls
}
