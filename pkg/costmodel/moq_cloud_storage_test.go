// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package costmodel

import (
	"context"
	"os"
	"sync"
)

// Ensure, that CloudStorageMock does implement CloudStorage.
// If this is not the case, regenerate this file with moq.
var _ CloudStorage = &CloudStorageMock{}

// CloudStorageMock is a mock implementation of CloudStorage.
//
//	func TestSomethingThatUsesCloudStorage(t *testing.T) {
//
//		// make and configure a mocked CloudStorage
//		mockedCloudStorage := &CloudStorageMock{
//			FileDownloadFunc: func(ctx context.Context, path string) (*os.File, error) {
//				panic("mock out the FileDownload method")
//			},
//			FileExistsFunc: func(ctx context.Context, path string) (bool, error) {
//				panic("mock out the FileExists method")
//			},
//			FileReplaceFunc: func(ctx context.Context, f *os.File, path string) error {
//				panic("mock out the FileReplace method")
//			},
//		}
//
//		// use mockedCloudStorage in code that requires CloudStorage
//		// and then make assertions.
//
//	}
type CloudStorageMock struct {
	// FileDownloadFunc mocks the FileDownload method.
	FileDownloadFunc func(ctx context.Context, path string) (*os.File, error)

	// FileExistsFunc mocks the FileExists method.
	FileExistsFunc func(ctx context.Context, path string) (bool, error)

	// FileReplaceFunc mocks the FileReplace method.
	FileReplaceFunc func(ctx context.Context, f *os.File, path string) error

	// calls tracks calls to the methods.
	calls struct {
		// FileDownload holds details about calls to the FileDownload method.
		FileDownload []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
		}
		// FileExists holds details about calls to the FileExists method.
		FileExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
		}
		// FileReplace holds details about calls to the FileReplace method.
		FileReplace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// F is the f argument value.
			F *os.File
			// Path is the path argument value.
			Path string
		}
	}
	lockFileDownload sync.RWMutex
	lockFileExists   sync.RWMutex
	lockFileReplace  sync.RWMutex
}

// FileDownload calls FileDownloadFunc.
func (mock *CloudStorageMock) FileDownload(ctx context.Context, path string) (*os.File, error) {
	if mock.FileDownloadFunc == nil {
		panic("CloudStorageMock.FileDownloadFunc: method is nil but CloudStorage.FileDownload was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
	}{
		Ctx:  ctx,
		Path: path,
	}
	mock.lockFileDownload.Lock()
	mock.calls.FileDownload = append(mock.calls.FileDownload, callInfo)
	mock.lockFileDownload.Unlock()
	return mock.FileDownloadFunc(ctx, path)
}

// FileDownloadCalls gets all the calls that were made to FileDownload.
// Check the length with:
//
//	len(mockedCloudStorage.FileDownloadCalls())
func (mock *CloudStorageMock) FileDownloadCalls() []struct {
	Ctx  context.Context
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Path string
	}
	mock.lockFileDownload.RLock()
	calls = mock.calls.FileDownload
	mock.lockFileDownload.RUnlock()
	return calls
}

// FileExists calls FileExistsFunc.
func (mock *CloudStorageMock) FileExists(ctx context.Context, path string) (bool, error) {
	if mock.FileExistsFunc == nil {
		panic("CloudStorageMock.FileExistsFunc: method is nil but CloudStorage.FileExists was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
	}{
		Ctx:  ctx,
		Path: path,
	}
	mock.lockFileExists.Lock()
	mock.calls.FileExists = append(mock.calls.FileExists, callInfo)
	mock.lockFileExists.Unlock()
	return mock.FileExistsFunc(ctx, path)
}

// FileExistsCalls gets all the calls that were made to FileExists.
// Check the length with:
//
//	len(mockedCloudStorage.FileExistsCalls())
func (mock *CloudStorageMock) FileExistsCalls() []struct {
	Ctx  context.Context
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Path string
	}
	mock.lockFileExists.RLock()
	calls = mock.calls.FileExists
	mock.lockFileExists.RUnlock()
	return calls
}

// FileReplace calls FileReplaceFunc.
func (mock *CloudStorageMock) FileReplace(ctx context.Context, f *os.File, path string) error {
	if mock.FileReplaceFunc == nil {
		panic("CloudStorageMock.FileReplaceFunc: method is nil but CloudStorage.FileReplace was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		F    *os.File
		Path string
	}{
		Ctx:  ctx,
		F:    f,
		Path: path,
	}
	mock.lockFileReplace.Lock()
	mock.calls.FileReplace = append(mock.calls.FileReplace, callInfo)
	mock.lockFileReplace.Unlock()
	return mock.FileReplaceFunc(ctx, f, path)
}

// FileReplaceCalls gets all the calls that were made to FileReplace.
// Check the length with:
//
//	len(mockedCloudStorage.FileReplaceCalls())
func (mock *CloudStorageMock) FileReplaceCalls() []struct {
	Ctx  context.Context
	F    *os.File
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		F    *os.File
		Path string
	}
	mock.lockFileReplace.RLock()
	calls = mock.calls.FileReplace
	mock.lockFileReplace.RUnlock()
	return calls
}
